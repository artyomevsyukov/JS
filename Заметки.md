Отличие класса от new Function
Однако есть важные отличия:

1. Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[IsClassConstructor]]: true. Поэтому это не совсем то же самое, что создавать её вручную.

В отличие от обычных функций, конструктор класса не может быть вызван без new:
Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»

2. Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".

И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.

3. Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.
    <!-- ...................................................... -->
    prototype доступен только для функциональных объектов или классы
    prototype шаблон болванка (ссылка на основе чего оно создается)
    prototype - ссылается на объект на конструктор, на шаблон на основание чего дальше будут создаваться инстансы экземпляры и после этого в новом записывается в свойство **proto** записывается свойство prototype т.к. prototype доступен только для функциональтных объектов
    **proto** записывается прототип его родитея

У любого объекта есть **proto** но prototype есть только у функции конструктор и класса. **proto** позволяет перемещаться по цепочке прототипов. А prototype это свойство функции которое позволяет добавлять что-то в конструктор. Например выше я уже добавлял в Object.prototype свою функцию. prototype будет так же и у простых функций, внутри функций всегда есть конструктор, даже если мы не используем его. prototype ссылается на конструктор!

**proto** ссылается на prototype класса с помощью которого был создан объект. Когда мы создали массив то его **proto** будет равно Array.prototype потому что **proto** ссылается на этот прототип. **proto** есть у любого объекта, а prototype у class либо function. Так же и **proto** есть у функций и классов это свойство есть У ВСЕХ!

Book.prototype.read -создает метод read для всех инстансво от Book, то есть Book.prototype значит что не у книги есть прототип а у инстанса будет прототип который будетв точности равен Book.prototype
поэтому все что мы объявляем в Book.prototype передается нашему инстансу и доступно ему через прототип
а **proto** показывает кто прототиа

... Остаточные параметры (...) Буквально это значит: «собери оставшиеся параметры и положи их в массив».

"use strict";
Alt + shift + a - комментарии
console.log(this)

Работа с формами через Form API
const data = new FormData(event.target);
console.log(event.target);
Обращение к полю с именем comment
const comment = data.get("comment");

Reference Error - Ошибка ссылки

Object.getOwnPropertyDescriptor(obj, propertyName) позволяет получить полную информацию о свойстве.
let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
console.log( JSON.stringify(descriptor, null, 2 ) );

Object.defineProperty(obj, propertyName, descriptor) Чтобы изменить флаги

Дескриптор (лат. descriptor — описывающий, идентификатор, описание) – лексическая единица в компьютерных информационных системах, предназначенная для описания свойств, параметров, идентификации тех или иных объектных элементов языка

scope - обдасть, область кода где переменная доступна (три вида: глобальный, функциональный и блочный)
scope chaning - области видимости (цепочки областей)
heap - куча

call stack(стек вызовов) , исполнение нашего контекста какой контекст сейчас активен
scope chain наследование скопов области видимости переменных, как переменная помещается в тот или иной контекст (объявлением переменной в лексическом скопе)

среда исполнения JAVASCRIPT в браузере:
-Движок JS
-WEB APIs
-callback Queue (очередь обратного вызова) очередь

Контекст:
контекст исполнение создается перед исполнением, после компиляции.
1.Создание глобального контекста
2.Выполнение кода верхнего уровня
3.Выполнение функций и ожидание callback
Что там находится:
1 - объявление переменных (let, const, var, function, arguments)
2 - scope области видимости
3 - this

This - переменная, которая создается для каждого контекста исполения. Она указывает на владельца этой функции.
This не статичен и определяется только при вызове функции в зависимости от того, как она вызвана.
Execution context - контекст выполнения

https://habr.com/ru/companies/ruvds/articles/422089/

ExecutionContext = {
-ThisBinding = <this value>,
-LexicalEnvironment = { ... },
-VariableEnvironment = { ... },
}

Стек выполнения (execution stack), который ещё называют стеком вызовов (call stack), это LIFO-стек, который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.

"заимствование метода"
Чем это
[].join.call(arguments)
Лучше чем это ?
Array.from(arr).join(',')

Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).

// клон obj c тем же прототипом (с поверхностным копированием свойств)
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));

Полифил – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript, но ещё не поддерживается текущим движком JavaScript.

Array.from
Есть универсальный метод Array.from, который принимает итерируемый объект или псевдомассив и делает из него «настоящий» Array. После этого мы уже можем использовать методы массивов.

https://learn.javascript.ru/iterable#array-from

в JavaScript функции возвращаются как значения, и их можно сохранять в переменных.

IIFE - Immediately-invoked function expressions» (сокращенно IIFE).

Замыкание:
приватные переменные которыми можно отдельно управлять через функции

Игнорирование индексации
git commit -a -m 'Add new benchmarks'
https://git-scm.com/book/ru/v2/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B9

Начало работы
проектирование
-Определение пользавательских сценариев

thisArg нужен если мы передаем в качестве функции метод объекта, тогда нужен контекст
let army = {
minAge: 18,
maxAge: 27,
canJoin(user) {
return user.age >= this.minAge && user.age < this.maxAge;
}
};
let soldiers = users.filter(army.canJoin, army);

!!!VS code Ctrl+Alt+b Создает область для размещения консоли справо!!!!

Что такое выраженеи от инструкции, выражение инструкция
Выражение а=а+1 т.к. мы не объявляем переменную, а только присваиваем новое значение

jsdoc
Задача 10 jsdoc
коментарии к функциям

Открываем вкладку Console, вставляем команду document.body.contentEditable = true, нажимаем Enter. Теперь можно редактировать любой текстовый элемент на странице напрямую. Естественно, исправленный текст останется до перезагрузки страницы и никак не повлияет на сайт.

//рекурсия

контексте выполнения (execution context).

Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в данном примере) и прочую служебную информацию.

Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
