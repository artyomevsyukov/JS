// Разбираемся в миксинах и событиях

let eventMixin = {
    /**
     * Подписаться на событие, использование:
     * menu.on('select', function(item) { ... }
     */
    on(eventName, handler) {
        if (!this._eventHandlers) this._eventHandlers = {}; // если нет объекта this._eventHandlers - создаём
        if (!this._eventHandlers[eventName]) {
            //если по имени eventName ничего нет
            this._eventHandlers[eventName] = []; //то создаём массив
        }
        this._eventHandlers[eventName].push(handler); // в массив eventName добавляем событие handler)
        // console.log(this._eventHandlers);
        // console.log(this._eventHandlers[eventName]);
    },

    /**
     * Отменить подписку, использование:
     * menu.off('select', handler)
     */
    off(eventName, handler) {
        let handlers = this._eventHandlers && this._eventHandlers[eventName];
        /* если не существует объекта this._eventHandlers и его поля [ eventName ] то результатом логической операции будет ложь (false). если же оба условия соблюдаются то в ячейку handlers запишется ПОСЛЕДНЕЕ значение - то есть либо содержимое ячейки [ eventName ] - если это примитив, либо ссылка на объект, если это объект. в этой ячейке, если она есть, как мы помним, хранится массив (с handler), следовательно ссылка на него и будет записана в переменной handlers.
Резюмирую, если в ячейке this._eventHandlers[eventName] что-то есть, то это -  массив с handler-ами, и теперь ссылка на него находится в переменной handlers.
*/
        if (!handlers) return; // если-таки массива с таким именем  нет eventName - то и разговаривать не о чем - выходим (а если нет даже объекта, где хранятся эти массивы - то тем более...)
        for (
            let i = 0;
            i < handlers.length;
            i++ //перебираем этот массив с handler-ами
        ) {
            if (handlers[i] === handler) {
                //и когда значение ячейки совпадает с искомым handler
                handlers.splice(i--, 1); //то мы этот handler удаляем
            }
        }
    },
    /**
     * Сгенерировать событие с указанным именем и данными
     * this.trigger('select', data1, data2);
     */
    trigger(eventName, ...args) {
        if (!this._eventHandlers || !this._eventHandlers[eventName]) {
            /* если не существует объекта, где хранятся массивы с событиями, а также записи [eventName] в ней */
            return; // выходим - генерировать негде
        }
        this._eventHandlers[eventName].forEach((handler) => {
            console.log(handler);
            return handler.apply(this, args);
        });
        /* Применяется для каждого элемента массива [eventName], который по видимому является функцией.
              Так вот, запускается КАЖДАЯ функция, лежащая в этом массиве, с одними и теми же аргументами, лежащими в args. Напомню args формируется как все аргументы, начиная со второго (а первый аргумент указывает имя ячейки, где хранится массив с функциями). В общем, вызываем массив однотипных (по-видимому) функций, с одинаковыми аргументами. Первым аргументом является имя массива (что позволяет нам найти этот массив, где хранятся все эти функции), все последующие аргументы, подсовываются каждой функции*/
    },
};
/*
 Итак, на что это похоже. У нас есть объект у которого есть три метода. При этом эти методы, по-видимому, могут быть вызваны, как из самого этого объекта, так и быть экспортиваны в любой другой объект и использоваться там. Какой-то особой разницы я не вижу, но, разумеется, при экспорте, нужно следить чтоб не возникли конфликты с именами свойств того объекта, куда осуществляется импорт.
Теперь, что это за методы. Метод 'on' - записывает новую функцию, в массив, предположительно однотипных функций. Собственно у него два аргумента - имя массива, куда следует записать функцию и сама функция. При этом, если по этому имени, до этого, функций не было, то массив автоматически будет создан. А если уже создан, то в него просто добавляется ещё одна функция.
off - там указывается имя массива функций и имя самой функции (какой-то указатель на функцию). Соответственно, в массиве функций ищется нужная нам функция и красиво удаляется из массива со сдвигом. Ищется по принципу полного совпадения. Тут варианта два. если эта функция была записана прямо внутри функции добавления, значит ссылок на эту функцию больше нигде нет, а значит, она удалиться из памяти сборщиком мусора, если же функция была объявлена где-то извне, то наш метод удалит только ссыдку на эту функцию, из нашего массива. А к функции, по-видимому, можно будет обратится напрямую, без наших хитрых вызовов :-)
Тригер проверяет есть ли массив с функциями по указаному имени (певый аргумент), и запускает все имеющиеся (в этом массиве) функции, со всеми последующими аргументами. Например, trigger(MegaEvent, 1, 2, 3, 'Masha') означает что по адресу this.MegaEvent предположительно лежит массив с функциями, если это не так, то ничего не произойдёт, а если есть, то вызовется каждая функция из этого массива, с аргументами  1, 2, 3, 'Masha'. Ну вот как-то так.
 */

// Создадим класс
class Menu {
    choose(value) {
        this.trigger("select", value);
        /*итак наш прекрасный класс, имеет по-умолчанию, всего один метод. И этот метод всего лишь вызывает массив select (который, в текущем объекте будет расположен  this._eventHandlers[select] ), в котором запускаются все функции с аргументов value. Очевидно, что для того, чтоб всё это запустилось, как минимум массив с таким именем, и с функциями внутри, должен быть... */
    }
}
// Добавим примесь с методами для событий
Object.assign(Menu.prototype, eventMixin);
// Вот эта маленькая строчка делает не так уж мало :-) У нас есть мааааленький класс, всего с одним методом. Помним, что в самом Menu лежит только конструктор (которого тут нет, и, так называемые статические функции, опять же, если они есть), все остальные методы помещаются в объект Menu.prototype. И, так как функция choose - не конструктор, она, соответственно, тоже помещается в Menu.prototype. А дальше мы к этому маленькому объекту копируем (или точнее прописываем ссылки, поскольку речь идёт об объектах) на большой объект eventMixin, в котором у нас есть, как мы помним уже три метода. В результате у нас пустая функция Menu (конструктора-то нет), соответственно, при вызове с new тупо создаётся пустой объект, но зато весьма раздутый Menu.prototype, который будет являться прототипом создаваемого объекта, и, когда у объекта нет собственных методов, он заимствует их в прототипе...(а в полях прототипа ссылка на "собственную функцию" и на три функции eventMixin, точнее, на методы, но это уже, больше терминологичесеи тонкости - функция, как значение поле объекта, называется методом...)

let menu = new Menu(); // В данном случае, это, наверное, аналогично let menu = Object.create(Menu.prototype)

// ну что ж, начнём =) заполняем вновь созданный объект всякой хренью, используя методы из прототипа Menu.prototype (в котором, в свою очередь, куча методов из eventMixin)
menu.on("select", (value) => console.log(`Выбранное значение: ${value}`));
/* итак создаём массив select, который будет располагаться по адресу menu._eventHandlers[select].
И сразу в этот массив запихиваем первую функцию (небольшую стрелочную функцию)
Давайте сами уже сделаем что-нибудь подобное*/

menu.on("select", (value) =>
    console.log(
        `Давайте ещё раз посмотрим на это прекрасное значение, всё равно оно у нас может быть только одно: ${value}`
    )
);

// Генерирует событие => обработчик выше запускается и выводит:
menu.choose("123"); // вызовется две функиции из массива select, сначала одна, потом другая

//давайте теперь что-нибудь другое забабахаем

menu.on("pow", (value) =>
    console.log(`квадрат числа ${value}: ${Math.pow(value, 2)}`)
);
menu.on("pow", (value) =>
    console.log(`куб числа ${value}: ${Math.pow(value, 3)}`)
);
menu.on("pow", (value) =>
    console.log(`пятая степерь числа ${value}: ${Math.pow(value, 5)}`)
);

//вызовем вручную:

menu.trigger("pow", 5); // Итак число пять будем последовательно возводить в степень

// как удалить безымянные функции - не думал, но, главное понимать где они находятся :-) а там уж найти как до них можно добраться - можно. да и потом пример на коленке, предполагается, видимо, что это не белки-стрелки будут, а большие и толстые именованные функции, и их коллекции :-)
// впрочем давайте вручную удалим последнюю пятую степень и сохраним в переменную
let pow4 = menu._eventHandlers.pow.pop();

pow4(125); //вызовем

menu.on("pow", (value) =>
    console.log(`четвёртая степерь числа ${value}: ${Math.pow(value, 4)}`)
); //для порядка добавим четвёртую степень

menu.trigger("pow", 10); // и снова вызовем с новым значением
